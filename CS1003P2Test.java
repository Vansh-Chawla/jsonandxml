import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class CS1003P2Test {
    
    /** 
     * This class is for running the provided tests for the practical.
     * 
     * @param args The command line arguments. We don't expect any for this program.
     */
    public static void main(String[] args) {
        try {
            runAllTests();
        }
        catch (IOException e) {
            e.printStackTrace();
        }
    }

    
    /** 
     * Method to run all tests stored in the samples directory.
     * 
     * @throws IOException
     */
    public static void runAllTests() throws IOException {

        // Our sample input output pairs are stored in a directory called samples.
        // Let's create an object to refer to this directory.
        File samples = new File("samples");

        // Get all files in the samples directory
        String[] files = samples.list();

        // Get a consistent ordering
        Arrays.sort(files);

        // We iterate through all files in the samples directory and test them
        for (String file : files) {
            runTest(file);
        }
    }

    
    /** 
     * Run a single test.
     * It takes the file path to the *.in file as an argument and runs the test specified in this file.
     * The method checks whether the file extension is *.in, if it isn't it doesn't do anything.
     * 
     * @param file This is the file path to the *.in file
     * @throws IOException
     */
    public static void runTest(String file) throws IOException {

        // Split the full filename on the dot character
        String[] parts = file.split("\\.");

        // If it had two parts and the file extension is "in", this is a test case
        if (parts.length == 2 && parts[1].equals("in")) {

            String base = parts[0];
            String inputFile = "samples" + File.separator + base + ".in";
            String outputFile = "samples" + File.separator + base + ".out";

            // This is the command for this test case. It is stored in the first line of the file.
            String command = Files.readAllLines(Paths.get(inputFile)).get(0);

            System.out.println("Test case: " + inputFile + " " + outputFile);
            System.out.println("Running command: " + command);
            
            // Run the command and collect its standard output
            List<String> stdout = runCommand(command);

            // Read the expected output from the output file
            List<String> expected = Files.readAllLines(Paths.get(outputFile));

            // Error reporting
            reportErrors(stdout, expected);
        }
    }

    
    /** 
     * A generic method for running a command.
     * Runs the command and returns the standard output produced by the command as a list of lines.
     * 
     * @param command The command to be run
     * @return List<String> The stdanard output
     * @throws IOException
     */
    private static List<String> runCommand(String command) throws IOException {
        
        Runtime rt = Runtime.getRuntime();
        Process pr = rt.exec(command);
        BufferedReader reader = new BufferedReader(new InputStreamReader(pr.getInputStream()));

        // This is where we collect the standard output
        List<String> stdout = new ArrayList<>();
        String line;
        while ((line = reader.readLine()) != null) {
            stdout.add(line);
        }
        return stdout;
    }

    
    /** 
     * Reports the errors (if any) to the user.
     * If there are too many errors in a single test case this method prints only the first 5 mismatching lines.
     * 
     * @param stdout The standard output generated by running the test
     * @param expected The expected output
     */
    private static void reportErrors(List<String> stdout, List<String> expected) {
        boolean pass = true;
        if (stdout.size() != expected.size()) {
            System.out.println("ERROR: Expected " + expected.size() + " lines, but got " + stdout.size());
            pass = false;
        }

        int error_count = 0; // Only print the first 5 mismatch lines, so we don't clutter the output.
        for (int i = 0; i < Math.min(expected.size(), stdout.size()) && error_count < 5; i++) {
            if (!expected.get(i).equals(stdout.get(i))) {
                error_count++;
                pass = false;
                System.out.println("ERROR: Mismatch on line " + (i+1));
                System.out.println("\tExpected: " + expected.get(i));
                System.out.println("\tBut got : " + stdout.get(i));

                // This is a common error, let's highlight it
                if (expected.get(i).contains("\t") && !stdout.get(i).contains("\t")) {
                    System.out.println("\tNotice that the expected line has tab characters in it.");
                }
            }
        }

        if (pass) {
            System.out.println("Passed.");
        }
        System.out.println();
    }

}

